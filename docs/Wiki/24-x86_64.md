<!--
SPDX-FileCopyrightText: 2026 * <dsls.dzc@gmail.com>

SPDX-License-Identifier: CC-BY-4.0
-->

# x86_64 架构

## 概述

HIC 支持 x86_64 架构，利用其强大的性能和丰富的硬件特性。本文档详细介绍了 HIC 在 x86_64 架构上的实现细节和优化。

## 架构特性

### CPU 特性

- **特权级**: Ring 0 (Core-0), Ring 3 (Application-3)
- **64位地址空间**: 支持 64 位物理和虚拟地址
- **TSC**: 时间戳计数器用于性能测量
- **系统调用**: syscall/sysret 快速系统调用指令
- **MMU**: 支持页式内存管理（虽然 HIC 主要使用物理内存）

### 寄存器上下文

```c
// x86_64 寄存器上下文
typedef struct arch_context {
    // 通用寄存器
    u64 rax, rbx, rcx, rdx;
    u64 rsi, rdi, rbp, rsp;
    u64 r8, r9, r10, r11;
    u64 r12, r13, r14, r15;
    
    // 特殊寄存器
    u64 rip;              // 指令指针
    u64 rflags;           // 标志寄存器
    u64 cr0, cr2, cr3, cr4;  // 控制寄存器
    
    // 栈信息
    u64 kernel_rsp;       // 内核栈指针
    u64 user_rsp;         // 用户栈指针
    u64 cs, ds, es, fs, gs, ss; // 段寄存器
} arch_context_t;
```

## 系统调用

### 快速系统调用

```c
// x86-64 快速系统调用
static inline u64 fast_syscall(u64 num, u64 arg1, u64 arg2, u64 arg3) {
    u64 result;
    __asm__ volatile (
        "syscall"
        : "=a"(result)
        : "a"(num), "D"(arg1), "S"(arg2), "d"(arg3)
        : "rcx", "r11", "memory"
    );
    return result;
}

// 目标: 20-30 ns (60-90 周期 @ 3GHz)
```

### 系统调用入口

```c
// 系统调用入口点
void syscall_entry(void) {
    // 保存用户上下文
    save_user_context();
    
    // 获取系统调用号
    u64 syscall_num = get_syscall_number();
    
    // 获取参数
    u64 arg1 = get_syscall_arg(0);
    u64 arg2 = get_syscall_arg(1);
    u64 arg3 = get_syscall_arg(2);
    u64 arg4 = get_syscall_arg(3);
    
    // 执行系统调用
    syscall_handler(syscall_num, arg1, arg2, arg3, arg4);
    
    // 恢复用户上下文
    restore_user_context();
    
    // 返回用户态
    __asm__ volatile ("sysretq");
}
```

## 中断处理

### 中断描述符表（IDT）

```c
// IDT 条目
typedef struct idt_entry {
    u16 offset_low;
    u16 selector;
    u8  ist;
    u8  type_attr;
    u16 offset_mid;
    u32 offset_high;
    u32 reserved;
} __attribute__((packed)) idt_entry_t;

// IDT 设置
static idt_entry_t idt[256];

void init_idt(void) {
    // 设置所有中断门
    for (u32 i = 0; i < 256; i++) {
        idt[i].offset_low = (u16)((u64)irq_handler & 0xFFFF);
        idt[i].selector = KERNEL_CS;
        idt[i].ist = 0;
        idt[i].type_attr = 0x8E;  // 中断门
        idt[i].offset_mid = (u16)((u64)irq_handler >> 16) & 0xFFFF;
        idt[i].offset_high = (u32)((u64)irq_handler >> 32);
        idt[i].reserved = 0;
    }
    
    // 加载 IDT
    u64 idtr = ((u64)sizeof(idt) - 1) << 48 | (u64)idt;
    __asm__ volatile ("lidt %0" : : "m"(idtr));
}
```

### 中断处理

```c
// 中断处理入口
void irq_handler(void) {
    // 获取中断向量
    u64 irq_vector = get_irq_vector();
    
    // 清除中断
    outb(0x20, 0x20);  // EOI
    
    // 查找处理程序
    irq_handler_t handler = irq_static_routes[irq_vector];
    if (handler) {
        handler(irq_vector);
    }
}
```

## 内存管理

### 页表

```c
// 页表项
typedef struct page_table_entry {
    u64 present : 1;
    u64 writable : 1;
    u64 user : 1;
    u64 write_through : 1;
    u64 cache_disable : 1;
    u64 accessed : 1;
    u64 dirty : 1;
    u64 pat : 1;
    u64 global : 1;
    u64 available : 3;
    u64 frame : 40;
} __attribute__((packed)) page_table_entry_t;

// 虽然 HIC 主要使用物理内存，但页表用于地址空间布局
```

### CR3 控制

```c
// 读取 CR3
static inline u64 read_cr3(void) {
    u64 value;
    __asm__ volatile ("mov %%cr3, %0" : "=r"(value));
    return value;
}

// 写入 CR3
static inline void write_cr3(u64 value) {
    __asm__ volatile ("mov %0, %%cr3" : : "r"(value) : "memory");
}
```

## 性能优化

### 时间戳计数器（TSC）

```c
// 读取 TSC
static inline u64 rdtsc(void) {
    u32 low, high;
    __asm__ volatile("rdtsc" : "=a"(low), "=d"(high));
    return ((u64)high << 32) | low;
}

// 测量操作延迟
u64 measure_cycles(void (*func)(void)) {
    u64 start = rdtsc();
    func();
    u64 end = rdtsc();
    return end - start;
}
```

### 缓存优化

```c
// 缓存行大小
#define CACHE_LINE_SIZE 64

// 缓存行对齐
typedef struct __attribute__((aligned(CACHE_LINE_SIZE))) cache_aligned {
    u64 data1;
    u64 data2;
    // ...
} cache_aligned_t;
```

## 上下文切换

### 快速上下文切换

```c
// 快速上下文切换（只切换必要寄存器）
void fast_context_switch(thread_t *prev, thread_t *next) {
    __asm__ volatile (
        // 保存 RSP
        "mov %%rsp, %0\n"
        // 恢复 RSP
        "mov %1, %%rsp\n"
        : "=m"(prev->rsp)
        : "m"(next->rsp)
        : "memory"
    );
}
```

## 调试支持

### 调试寄存器

```c
// 读取调试寄存器
static inline u64 read_dr(u64 reg_num) {
    u64 value;
    __asm__ volatile ("mov %%dr%1, %0" : "=r"(value) : "d"(reg_num));
    return value;
}
```

## 最佳实践

1. **使用快速指令**: 使用 syscall/sysret 等快速指令
2. **优化缓存**: 优化数据布局提高缓存命中率
3. **避免分支**: 减少分支预测失败
4. **测量性能**: 使用 TSC 精确测量性能

## 相关文档

- [ARM64 架构](./25-ARM64.md) - ARM64 架构
- [RISC-V 架构](./26-RISC-V.md) - RISC-V 架构
- [快速路径](./19-FastPath.md) - 快速路径优化

---

*最后更新: 2026-02-14*