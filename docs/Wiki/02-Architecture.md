<!--
SPDX-FileCopyrightText: 2026 DslsDZC <dsls.dzc@gmail.com>

SPDX-License-Identifier: CC-BY-4.0
-->

# 架构设计

HIC采用创新的三层模型架构，通过物理内存直接映射和能力系统，实现了高性能、强隔离和动态可扩展的统一。

## 三层模型架构

### 架构概览

```
┌─────────────────────────────────────────────────────────┐
│              Application-3 (Ring 3)                    │
│         不可信用户代码 | 虚拟地址空间                    │
└────────────────────┬────────────────────────────────────┘
                     │ 系统调用
                     ▼
┌─────────────────────────────────────────────────────────┐
│            Core-0 (Ring 0)                             │
│   内核核心与仲裁者 | 能力系统 | 资源管理               │
│   代码行数 < 10,000行 | 可形式化验证                   │
└──────┬───────────────────────────────────────┬──────────┘
       │                                       │
       │ 中断路由                              │ 服务调用
       ▼                                       ▼
┌─────────────────────────────────────────────────────────┐
│          Privileged-1 (Ring 0)                         │
│      特权服务沙箱 | 物理内存直接映射                    │
│  ┌─────────┬─────────┬─────────┬─────────┐            │
│  │ 网络驱动│ 文件系统│ 图形服务│ ...     │            │
│  └─────────┴─────────┴─────────┴─────────┘            │
│  独立物理内存区域 | MMU隔离 | 能力限制                  │
└─────────────────────────────────────────────────────────┘
```

### 层级职责

#### Core-0层：内核核心与仲裁者

**物理执行环境**: CPU最高特权模式（x86 Ring 0，ARMv8-A EL1/EL2）

**逻辑角色**: 系统的可信计算基（TCB），资源访问的最终仲裁者

**设计目标**: 极简、可形式化验证，代码规模<10,000行C代码

**核心职责**:

1. **物理资源管理与分配**
   - 管理所有物理内存帧、CPU时间片、硬件中断线
   - 直接物理内存分配，无虚拟内存开销
   - 为每个隔离域分配独立的物理内存区域

2. **能力系统内核**
   - 维护全局受保护的能力表
   - 每个域关联能力空间（能力句柄数组）
   - 提供能力传递、派生、撤销系统调用

3. **执行控制与调度**
   - 管理所有线程控制块（TCB）
   - 实现可预测的实时调度器
   - 处理所有异常和硬件中断

4. **隔离强制实施**
   - 为Privileged-1服务配置页表
   - 服务无法修改自身页表
   - 控制流转移通过同步调用门

#### Privileged-1层：特权服务沙箱

**物理执行环境**: 与Core-0相同（x86 Ring 0，ARMv8-A EL1/EL2）

**逻辑角色**: 模块化的系统功能提供者

**关键设计**: 无传统虚拟地址空间

**核心特性**:

1. **物理内存直接映射**
   - 服务直接使用物理地址
   - 消除虚拟地址转换开销
   - 确定性的内存访问延迟

2. **物理空间隔离**
   - 不同服务的物理内存区域不重叠
   - 通过MMU页表权限相互隔离
   - 硬性配额限制资源使用

3. **基于能力的资源访问**
   - 服务启动时获得初始能力集
   - 所有资源访问通过能力验证
   - 能力传递需Core-0仲裁

4. **故障隔离与恢复**
   - 服务崩溃限制在自身物理地址空间
   - Core-0回收所有能力和资源
   - 监视器服务决定是否重启

5. **高效通信机制**
   - 与Application通信：零拷贝共享内存
   - 与Core-0通信：系统调用
   - 服务间通信：直接或间接通信

#### Application-3层：应用层

**物理执行环境**: CPU低特权模式（x86 Ring 3，ARMv8-A EL0）

**逻辑角色**: 不可信用户代码的执行环境

**核心特性**:

- 标准进程抽象
- 独立虚拟地址空间
- 所有资源请求通过系统API
- 应用间无直接内存访问

## 物理内存直接映射

### 设计原理

传统内核使用虚拟内存管理，存在以下开销：
- 页表遍历
- TLB缺失
- 页面错误处理

HIC采用物理内存直接映射：

```
传统虚拟内存架构：
┌─────────────────────────────────────────┐
│  应用虚拟地址空间                        │
│  ┌──────┐ ┌──────┐ ┌──────┐            │
│  │ 0x1000│ │ 0x2000│ │ 0x3000│            │
│  └──┬───┘ └──┬───┘ └──┬───┘            │
│     │        │        │                │
│     ▼        ▼        ▼                │
│  ┌─────────────────────────────┐       │
│  │   MMU页表转换               │       │
│  └─────────────────────────────┘       │
│     │        │        │                │
│     ▼        ▼        ▼                │
│  ┌──────┐ ┌──────┐ ┌──────┐            │
│  │物理页0│ │物理页1│ │物理页2│            │
│  └──────┘ └──────┘ └──────┘            │
└─────────────────────────────────────────┘

HIC物理直接映射架构：
┌─────────────────────────────────────────┐
│  Privileged-1服务                       │
│  ┌─────────────────────────────┐       │
│  │ 物理地址 0x100000-0x1FFFFF  │       │
│  │ (直接访问，无转换)          │       │
│  └─────────────────────────────┘       │
│  ┌─────────────────────────────┐       │
│  │ 物理地址 0x200000-0x2FFFFF  │       │
│  │ (直接访问，无转换)          │       │
│  └─────────────────────────────┘       │
└─────────────────────────────────────────┘
```

### 优势

1. **性能优势**
   - 消除页表遍历开销
   - 消除TLB缺失
   - 确定的内存访问延迟

2. **简化设计**
   - 无需复杂的虚拟内存管理
   - 简化服务内部内存管理
   - 减少上下文切换开销

3. **可预测性**
   - 内存访问延迟确定
   - 适合实时系统
   - 便于性能分析

### 内存布局示例

```
物理内存布局：
0x00000000 - 0x000FFFFF: Core-0代码和数据
0x00100000 - 0x001FFFFF: Core-0堆栈
0x00200000 - 0x002FFFFF: 网络服务
0x00300000 - 0x003FFFFF: 文件系统服务
0x00400000 - 0x004FFFFF: 图形服务
0x00500000 - 0x005FFFFF: 应用1虚拟空间
0x00600000 - 0x006FFFFF: 应用2虚拟空间
0x00700000 - 0x007FFFFF: 共享内存区域
0x00800000 - 0x008FFFFF: 设备MMIO区域
0x00900000 - 0x00FFFFFF: 保留
```

## 能力系统

### 能力概念

能力（Capability）是HIC中所有授权的载体：

```
能力结构：
┌─────────────────────────────────────┐
│ 能力ID (32位)                      │
├─────────────────────────────────────┤
│ 类型 (8位)                         │
│   - CAP_TYPE_MEMORY                │
│   - CAP_TYPE_IO_PORT               │
│   - CAP_TYPE_IPC_ENDPOINT          │
│   - CAP_TYPE_DEVICE                │
├─────────────────────────────────────┤
│ 权限 (16位)                        │
│   - CAP_PERM_READ                 │
│   - CAP_PERM_WRITE                │
│   - CAP_PERM_EXECUTE              │
│   - CAP_PERM_DERIVE               │
├─────────────────────────────────────┤
│ 资源描述 (64位)                    │
│   - 物理地址范围                  │
│   - I/O端口范围                   │
│   - 端点ID                        │
├─────────────────────────────────────┤
│ 所有者域ID (16位)                  │
├─────────────────────────────────────┤
│ 标志 (16位)                        │
│   - CAP_FLAG_REVOKED              │
│   - CAP_FLAG_DERIVABLE            │
└─────────────────────────────────────┘
```

### 能力操作

#### 1. 能力创建

```c
// Core-0在创建服务时分配初始能力
cap_id_t cap = cap_create(
    domain_id,           // 所有者域ID
    CAP_TYPE_MEMORY,     // 能力类型
    CAP_PERM_READ | CAP_PERM_WRITE,  // 权限
    phys_addr,           // 物理地址
    size                 // 大小
);
```

#### 2. 能力传递

```c
// 域A将能力传递给域B
status = cap_transfer(
    domain_a,      // 发送域
    domain_b,      // 接收域
    cap_id,        // 能力ID
    sub_rights     // 可选：子权限
);
```

#### 3. 能力派生

```c
// 创建权限子集
status = cap_derive(
    original_cap,  // 原始能力
    sub_rights,    // 子权限
    &new_cap       // 新能力
);
```

#### 4. 能力撤销

```c
// 撤销能力
status = cap_revoke(cap_id);
// 所有域中指向此能力的句柄立即失效
```

### 能力验证流程

```
资源访问请求：
1. 应用发起系统调用，携带能力句柄
2. Core-0验证：
   a) 句柄是否有效
   b) 能力是否被撤销
   c) 域是否持有此能力
   d) 权限是否足够
3. 如果验证通过，执行操作
4. 如果验证失败，返回权限错误
```

## 中断处理

### 中断路由机制

```
中断处理流程：
硬件中断 → Core-0入口 → 查找路由表 → 调用服务ISR → 返回
```

### 中断路由表

```c
// 构建时生成
typedef struct {
    uint32_t irq_vector;      // 中断向量号
    domain_id_t domain_id;    // 处理服务域ID
    void (*handler)(void);    // 处理函数入口
} irq_route_entry_t;

irq_route_entry_t irq_route_table[256] = {
    {32, DOMAIN_NETWORK, network_irq_handler},
    {33, DOMAIN_DISK, disk_irq_handler},
    // ...
};
```

### 性能优化

- 简化入口：只保存关键寄存器
- 直接调用：通过路由表直接调用服务ISR
- 无特权级切换：服务运行在Ring 0
- 目标延迟：0.5-1微秒

## 系统调用

### 系统调用路径

```
应用系统调用：
Application (Ring 3)
    ↓ syscall指令
Core-0入口 (Ring 0)
    ↓ 能力验证
Core-0路由
    ↓ 上下文切换
Privileged-1服务 (Ring 0)
    ↓ 处理请求
返回Core-0
    ↓ 上下文切换
返回Application (Ring 3)
```

### 系统调用性能

- 无特权级切换开销
- 无页表切换开销
- 能力验证：几次内存查表
- 受控的上下文跳转
- 目标延迟：20-30纳秒

## 调度器

### 调度策略

```
调度器类型：
1. 静态优先级调度（构建时配置）
   - 适合实时系统
   - 可预测性高

2. 轮转调度
   - 公平性好
   - 实现简单

3. 混合调度
   - 关键任务静态优先级
   - 普通任务轮转
```

### 线程切换

```
线程切换流程：
1. 保存当前线程上下文
2. 选择下一个线程
3. 恢复新线程上下文
4. 继续执行

开销：
- 保存/恢复通用寄存器
- 保存/恢复栈指针
- 保存/恢复线程私有数据
- 无需切换页表（除非跨域）
- 目标延迟：120-150纳秒
```

## 通信机制

### IPC（进程间通信）

#### 1. 同步IPC（控制流）

```
调用流程：
Application → Core-0 → Privileged-1服务 → Core-0 → Application
```

#### 2. 异步IPC（数据流）

```
共享内存流程：
1. Core-0分配共享物理内存
2. 映射到Application虚拟空间
3. 映射到Privileged-1服务物理空间
4. 创建内存能力授予双方
5. 零拷贝数据传输
```

### 通信性能

- 零拷贝共享内存
- 无内核缓冲区拷贝
- 带宽上限：内存复制速度或DMA速度

## 部署模式

### 静态合成模式

```
特点：
- 所有服务在构建时编译链接
- 单一、确定性内核映像
- 无运行时模块加载
- 极致确定性
- 最小化存储占用

适用场景：
- 嵌入式系统
- 实时系统
- 高安全系统
```

### 动态模块化模式

```
特点：
- 核心服务静态编译
- 扩展服务运行时加载
- 支持网络仓库
- 支持滚动更新
- 高度灵活

适用场景：
- 通用计算
- 桌面系统
- 服务器
```

## 架构优势

### 1. 性能优势

| 操作 | 传统微内核 | HIC | 提升 |
|------|-----------|-----|------|
| 系统调用 | 1-5μs | 20-30ns | 50-250x |
| 中断处理 | 5-10μs | 0.5-1μs | 5-20x |
| 线程切换 | 0.5-2μs | 120-150ns | 3-17x |

### 2. 安全优势

- 硬件MMU强制隔离
- 细粒度能力控制
- 完整的审计日志
- 形式化验证支持

### 3. 灵活性优势

- 支持静态和动态部署
- 支持滚动更新
- 支持API版本管理
- 支持多架构

## 与其他架构对比

详见 [项目概述](./01-Overview.md) 中的架构对比表格。

---

*最后更新: 2026-02-14*